# âœï¸ 13ì£¼ì°¨ \[8ê¸°\] Bë°˜ ìŠ¤í„°ë””

## ğŸ—“2023-04-08

**ì°¸ì—¬ì** : ë¦¬ì§€, vetto, ì†¡ì¤€

**ì§„í–‰ì** : vetto

  
## \[ê¸ˆì£¼ì˜ ì‹¤í—˜ğŸ”¥\] Cache

* ê° UIìš”ì†Œë“¤ì˜ ì—­í• ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.
* ImageView(2ê°œ): ë°›ì•„ì˜¨ ì´ë¯¸ì§€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
* ì´ë¯¸ì§€ ë°›ì•„ì˜¤ê¸°(2ê°œ): URLSessionì„ í†µí•´ ì´ë¯¸ì§€ URLë¡œë¶€í„° ì´ë¯¸ì§€ë¥¼ ë°›ì•„ì™€ ImageViewì— í‘œì‹œí•©ë‹ˆë‹¤. ë§Œì•½ ìºì‹œëœ ë°ì´í„°ê°€ ìˆë‹¤ë©´ ìºì‹œëœ ë°ì´í„°ë¥¼ í™œìš©í•©ë‹ˆë‹¤.
* ìºì‹œ ë°ì´í„°ê°€ ì—†ì„ ê²½ìš°: ì´ë¯¸ì§€ë¥¼ ìš”ì²­í•œ í›„, â€œìƒˆë¡œìš´ ì´ë¯¸ì§€ë¥¼ ë°›ì•„ì™”ìŠµë‹ˆë‹¤" ì¶œë ¥
* ìºì‹œ ë°ì´í„°ê°€ ìˆì„ ê²½ìš°: ìºì‹œëœ ë°ì´í„°ë¥¼ í™œìš©í•œ í›„, â€œìºì‹œëœ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤.â€ ì¶œë ¥
* ì´ë¯¸ì§€ ì´ˆê¸°í™”: ImageViewì˜ imageë¥¼ nilë¡œ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.
* ìºì‹œ ë¹„ìš°ê¸°: ì €ì¥ëœ ìºì‹œë¥¼ ëª¨ë‘ ì œê±°í•©ë‹ˆë‹¤.
* ê° UIìš”ì†Œë“¤ì´ ì˜ë„ëŒ€ë¡œ ë™ì‘í•˜ë„ë¡ Cacheë¥¼ ì´ìš©í•˜ì—¬ êµ¬í˜„í•©ë‹ˆë‹¤. 
* ë””ìŠ¤í¬ì— ì €ì¥í•˜ëŠ” ì‹œë„ëŠ” í•˜ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤.

### NSCache
```swift
struct NetworkManager {
    func loadImage(from imageURL: String, completion: @escaping ((Result<UIImage, NetworkError>) -> Void)) {
        guard let url = URL(string: imageURL) else { return }
        let urlRequest = URLRequest(url: url)
        
        let task = URLSession.shared.dataTask(with: urlRequest) { data, _, error in
            if error != nil {
                completion(.failure(.unknown))
                return
            }
            
            if let data = data {
                guard let result = UIImage(data: data) else {
                    completion(.failure(.decode))
                    return
                }
                completion(.success(result))
            }
        }
        task.resume()
    }
```

```swift
//ViewControllerì—ì„œ í™•ì¸í•˜ëŠ” ì½”ë“œ
    private func fetchImage(from imageURL: String, imageView: UIImageView) {
        if let cachedImage = ImageCacheManager.shared.cachedImage(urlString: imageURL) {
            DispatchQueue.main.async {
                print("ìºì‹œëœ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤.")
                imageView.image = cachedImage
            }
            return
        }
        
        networkManager.loadImage(from: imageURL) { result in
            switch result {
            case .failure(let error):
                print(error.description)
            case .success(let image):
                ImageCacheManager.shared.setObject(image: image, urlString: imageURL)
                DispatchQueue.main.async {
                    imageView.image = image
                    print("ìƒˆë¡œìš´ ì´ë¯¸ì§€ë¥¼ ë°›ì•„ì™”ìŠµë‹ˆë‹¤.")
                }
            }
        }
    }
```



### URLCache
```swift
struct NetworkManager {
    
    func loadURLCachedImage(from imageURL: URLRequest, completion: @escaping ((Result<(Data), NetworkError>) -> Void)) {
        
        // MARK: task ìƒì„±
        let task = URLSession.shared.dataTask(with: imageURL) { data, response, error in
            // MARK: task resumeì´ ë˜ë©´ì„œ ì‹¤í–‰
            if error != nil {
                completion(.failure(.unknown))
                return
            }
            
            guard response is HTTPURLResponse else {
                completion(.failure(.response))
                return
            }
            
            if let data = data,
               let response = response {
                let cachedResponse = CachedURLResponse(response: response, data: data)
                URLCache.shared.storeCachedResponse(cachedResponse, for: imageURL)
                print("ìƒˆë¡œ ì €ì¥")
                completion(.success(data))
            }
        }
        
        // MARK: task ìƒì„± í›„ ì‹¤í–‰ë˜ëŠ” ì½”ë“œ
        URLCache.shared.getCachedResponse(for: task) { cachedResponse in
            if let cachedResponse = cachedResponse {
                print("ìºì‹œëœ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤.")
                completion(.success(cachedResponse.data))
            } else {
                task.resume()
            }
        }
    }
}
```
```swift
// ViewControllerì—ì„œ ì‹¤í–‰í•˜ëŠ” ì½”ë“œ
    private func downloadImage(from imageURL: String, imageView: UIImageView) {
        guard let url = URL(string: imageURL) else { return }
        let request = URLRequest(url: url)
        
        networkManager.loadURLCachedImage(from: request) { result in
            switch result {
            case .failure(let error):
                print(error.description)
            case .success(let data):
                
                DispatchQueue.main.async {
                    let cachedImage = UIImage(data: data)
                    imageView.image = cachedImage
                }
                return
            }
        }
    }
```

###### tags: `toyo`